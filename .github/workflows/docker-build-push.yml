name: Build, Push and Deploy

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:
    inputs:
      environment:
        description: "Deployment Environment"
        required: true
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: "Docker Image Tag (leave empty to use latest)"
        required: false
        type: string

env:
  REGISTRY_URL: ${{ secrets.REGISTRY_URL }}
  IMAGE_NAME: ${{ secrets.IMAGE_NAME }}
  REGISTRY_USERNAME: ${{ secrets.REGISTRY_USER }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image_tag: ${{ steps.set-env.outputs.image_tag }}
    steps:
      - name: Determine environment and tag
        id: set-env
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag || 'latest' }}"
          else
            TAG_NAME=${GITHUB_REF#refs/tags/}
            IMAGE_TAG="${TAG_NAME}"
            if [[ "$TAG_NAME" == *"prod"* ]] || [[ "$TAG_NAME" == *"production"* ]]; then
              ENVIRONMENT="production"
            else
              ENVIRONMENT="staging"
            fi
          fi

          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "Determined environment: ${ENVIRONMENT}"
          echo "Image tag: ${IMAGE_TAG}"

  build-and-push:
    runs-on: ubuntu-latest
    needs: determine-environment
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create Firebase credentials file from secret
        run: |
          if [ -n "${{ secrets.FIREBASE_CREDENTIALS }}" ]; then
            echo "${{ secrets.FIREBASE_CREDENTIALS }}" > src/main/resources/firebase-credentials.json
            echo "‚úÖ Firebase credentials file created from secret"
          else
            echo "‚ö†Ô∏è Warning: FIREBASE_CREDENTIALS secret not set, creating empty file"
            mkdir -p src/main/resources
            echo '{}' > src/main/resources/firebase-credentials.json
          fi

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_URL }}
          username: ${{ env.REGISTRY_USERNAME }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: Validate and prepare tags
        id: tags
        run: |
          # Validate required variables
          if [ -z "${{ env.REGISTRY_URL }}" ]; then
            echo "Error: REGISTRY_URL is not set"
            exit 1
          fi
          
          if [ -z "${{ env.IMAGE_NAME }}" ]; then
            echo "Error: IMAGE_NAME is not set"
            exit 1
          fi
          
          ENV="${{ needs.determine-environment.outputs.environment }}"
          TAG="${{ needs.determine-environment.outputs.image_tag }}"
          
          # Ensure tag is not empty and sanitize
          if [ -z "${TAG}" ] || [ "${TAG}" == "null" ]; then
            TAG="latest"
          fi
          
          # Sanitize tag - remove invalid characters, convert to lowercase
          TAG=$(echo "${TAG}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]//g')
          ENV_LOWER=$(echo "${ENV}" | tr '[:upper:]' '[:lower:]')
          
          # Ensure tag doesn't start or end with invalid characters
          TAG=$(echo "${TAG}" | sed 's/^[.-]//;s/[.-]$//')
          
          # Validate tag is not empty after sanitization
          if [ -z "${TAG}" ]; then
            TAG="latest"
          fi
          
          # Create valid Docker tags (Docker tags must be lowercase)
          echo "tag1=${TAG}" >> $GITHUB_OUTPUT
          echo "tag2=${ENV_LOWER}-latest" >> $GITHUB_OUTPUT
          echo "tag3=${ENV_LOWER}-${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          
          echo "Registry: ${{ env.REGISTRY_URL }}"
          echo "Image: ${{ env.IMAGE_NAME }}"
          echo "Prepared tags: ${TAG}, ${ENV_LOWER}-latest, ${ENV_LOWER}-${GITHUB_SHA::7}"

      - name: Extract metadata (tags, labels)
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ steps.tags.outputs.tag1 }}
            type=raw,value=${{ steps.tags.outputs.tag2 }}
            type=raw,value=${{ steps.tags.outputs.tag3 }}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Cache Docker layers v√† Maven dependencies t·ª´ GitHub Actions cache
          cache-from: type=gha
          # L∆∞u cache v·ªõi mode=max ƒë·ªÉ cache c·∫£ cache mounts (Maven dependencies)
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      - name: Image info
        run: |
          echo "‚úÖ Image pushed successfully"
          echo "Tag: ${{ needs.determine-environment.outputs.image_tag }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

  create-deployment:
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-push]
    outputs:
      deployment_id: ${{ steps.create.outputs.deployment_id }}
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Create GitHub Deployment
        id: create
        uses: actions/github-script@v7
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: context.ref,
              environment: '${{ needs.determine-environment.outputs.environment }}',
              description: `Deploy ${{ needs.determine-environment.outputs.image_tag }} to ${{ needs.determine-environment.outputs.environment }}`,
              auto_merge: false,
              required_contexts: []
            });
            core.setOutput('deployment_id', deployment.data.id);
            console.log(`Created deployment ${deployment.data.id}`);

  deploy:
    runs-on: ubuntu-latest
    needs: [determine-environment, build-and-push, create-deployment]
    environment:
      name: ${{ needs.determine-environment.outputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_KEY }}

      - name: Prepare environment variables
        id: prepare
        run: |
          ENV="${{ needs.determine-environment.outputs.environment }}"
          TAG="${{ needs.determine-environment.outputs.image_tag }}"
          
          # Ensure tag is not empty and sanitize
          if [ -z "${TAG}" ] || [ "${TAG}" == "null" ]; then
            TAG="latest"
          fi
          
          # Sanitize tag - remove invalid characters, convert to lowercase
          TAG=$(echo "${TAG}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]//g')
          ENV_LOWER=$(echo "${ENV}" | tr '[:upper:]' '[:lower:]')
          
          # Ensure tag doesn't start or end with invalid characters
          TAG=$(echo "${TAG}" | sed 's/^[.-]//;s/[.-]$//')
          
          # Validate tag is not empty after sanitization, use environment-based tag as fallback
          if [ -z "${TAG}" ]; then
            TAG="${ENV_LOWER}-latest"
          fi
          
          echo "ENVIRONMENT=${ENV}" >> $GITHUB_ENV
          echo "IMAGE=${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${TAG}" >> $GITHUB_ENV
          echo "SSH_HOST=${{  secrets.SSH_HOST }}" >> $GITHUB_ENV
          echo "SSH_USER=${{  secrets.SSH_USER }}" >> $GITHUB_ENV
          echo "SSH_PORT=${{  secrets.SSH_PORT || '22' }}" >> $GITHUB_ENV
          echo "ENV_FILE_PATH=${{ secrets.ENV_FILE_PATH || '~/deploy/.env' }}" >> $GITHUB_ENV
          echo "Using image tag: ${TAG}"

      - name: Get previous version
        id: previous
        run: |
          PREV_VERSION=$(ssh -o StrictHostKeyChecking=no -p $SSH_PORT $SSH_USER@$SSH_HOST \
            "docker ps --filter 'name=vietmind-backend' --format '{{.Image}}' | grep -oP '(?<=:)[^ ]+' || echo 'none'")
          echo "previous_version=$PREV_VERSION" >> $GITHUB_OUTPUT
          echo "Previous version: $PREV_VERSION"

      - name: Verify .env file exists on server
        run: |
          echo "üîç Checking for .env file on server at path: $ENV_FILE_PATH"
          if ssh -o StrictHostKeyChecking=no -p $SSH_PORT $SSH_USER@$SSH_HOST "[ -f $ENV_FILE_PATH ]"; then
            echo "‚úÖ .env file found at: $ENV_FILE_PATH"
          else
            echo "‚ö†Ô∏è Warning: .env file not found at $ENV_FILE_PATH on server"
            echo "Container will run without environment variables from .env file"
            echo "Please ensure .env file exists or set ENV_FILE_PATH secret to the correct path"
          fi

      - name: Deploy container
        id: deploy
        run: |
          echo "üöÄ Deploying to $ENVIRONMENT"
          echo "üöÄ Deploying to $IMAGE"
          ssh -o StrictHostKeyChecking=no -p $SSH_PORT $SSH_USER@$SSH_HOST << EOF
            echo "${{ env.REGISTRY_PASSWORD }}" | docker login ${{ env.REGISTRY_URL }} -u ${{ env.REGISTRY_USERNAME }} --password-stdin
            docker pull $IMAGE
            docker stop vietmind-backend || true
            docker rm vietmind-backend || true
            docker run -d --name vietmind-backend --restart unless-stopped -p 9001:9001 --network vietmind-network --env-file $ENV_FILE_PATH -e SPRING_PROFILES_ACTIVE=prod $IMAGE
          EOF
          echo "deployment_status=deployed" >> $GITHUB_OUTPUT

      - name: Health check and rollback
        id: health
        run: |
          echo "‚è≥ Waiting 10 seconds for container to start..."
          sleep 10
          
          echo "üîç Performing health check..."
          MAX_RETRIES=6
          RETRY_DELAY=5
          HEALTH="unhealthy"
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Health check attempt $i/$MAX_RETRIES..."
            HEALTH=$(ssh -o StrictHostKeyChecking=no -p $SSH_PORT $SSH_USER@$SSH_HOST \
              "timeout 5 curl -f -s http://localhost:9001/actuator/health >/dev/null 2>&1 && echo healthy || echo unhealthy")
            echo "Health: $HEALTH"
            
            if [ "$HEALTH" == "healthy" ]; then
              break
            fi
            
            if [ $i -lt $MAX_RETRIES ]; then
              echo "‚è≥ Waiting ${RETRY_DELAY} seconds before retry..."
              sleep $RETRY_DELAY
            fi
          done
          
          if [ "$HEALTH" != "healthy" ]; then
            echo "‚ùå Health check failed after $MAX_RETRIES attempts, rolling back..."
            PREV_VERSION="${{ steps.previous.outputs.previous_version }}"
            if [ -n "$PREV_VERSION" ] && [ "$PREV_VERSION" != "none" ]; then
              # Sanitize and validate previous version tag
              PREV_TAG=$(echo "${PREV_VERSION}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9._-]//g' | sed 's/^[.-]//;s/[.-]$//')
              if [ -z "$PREV_TAG" ]; then
                PREV_TAG="latest"
              fi
              PREV_IMAGE="${{ env.REGISTRY_URL }}/${{ env.IMAGE_NAME }}:${PREV_TAG}"
              echo "Rolling back to: $PREV_IMAGE"
              ssh -o StrictHostKeyChecking=no -p $SSH_PORT $SSH_USER@$SSH_HOST << EOF
                docker stop vietmind-backend || true
                docker rm vietmind-backend || true
                docker run -d --name vietmind-backend --restart unless-stopped -p 9001:9001 --network vietmind-network --env-file $ENV_FILE_PATH -e SPRING_PROFILES_ACTIVE=prod $PREV_IMAGE
              EOF
              echo "rollback_status=rolled_back" >> $GITHUB_OUTPUT
              echo "deployment_status=failed_rolled_back" >> $GITHUB_OUTPUT
              exit 1
            else
              echo "‚ö†Ô∏è No previous version available for rollback"
              echo "rollback_status=no_previous_version" >> $GITHUB_OUTPUT
              echo "deployment_status=failed_no_rollback" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "‚úÖ Healthy deployment"
            echo "rollback_status=not_needed" >> $GITHUB_OUTPUT
            echo "deployment_status=success" >> $GITHUB_OUTPUT
          fi

      - name: Update deployment status
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const status = '${{ steps.health.outputs.deployment_status }}' === 'success' ? 'success' : 'failure';
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ needs.create-deployment.outputs.deployment_id }},
              state: status,
              description: `Deployment ${status}`
            });

      - name: Summary
        if: always()
        run: |
          echo "=========================================="
          echo "üìä DEPLOYMENT SUMMARY"
          echo "Environment: $ENVIRONMENT"
          echo "Image: $IMAGE"
          echo "Previous: ${{ steps.previous.outputs.previous_version }}"
          echo "Status: ${{ steps.health.outputs.deployment_status }}"
          echo "Rollback: ${{ steps.health.outputs.rollback_status }}"
          echo "=========================================="
